<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>http | Vesper Diesel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="httpajaxstatus code" />
  
  
  
  
  <meta name="description" content="HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 http消息结构客户端请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下四个部分：    请求行（request line） 请">
<meta property="og:type" content="article">
<meta property="og:title" content="http">
<meta property="og:url" content="http://example.com/2022/11/07/http/index.html">
<meta property="og:site_name" content="Vesper Diesel">
<meta property="og:description" content="HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 HTTP是一个基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 http消息结构客户端请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下四个部分：    请求行（request line） 请">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-07T07:33:28.000Z">
<meta property="article:modified_time" content="2022-11-07T06:24:33.034Z">
<meta property="article:author" content="Vesper">
<meta property="article:tag" content="http">
<meta property="article:tag" content="ajax">
<meta property="article:tag" content="status code">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Vesper Diesel" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("/css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("/css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("/css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>

  
<script src="/js/bootstrap.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    
<link rel="stylesheet" href="/css/dialog.css">

  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  

<meta name="generator" content="Hexo 6.3.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-http" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      http
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2022/11/07/http/" class="article-date">
	  <time datetime="2022-11-07T07:33:28.000Z" itemprop="datePublished">2022-11-07</time>
	</a>

      
    <a class="article-category-link" href="/categories/http/">http</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<h2 id="http消息结构"><a href="#http消息结构" class="headerlink" title="http消息结构"></a>http消息结构</h2><h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下四个部分：  </p>
<ul>
<li>请求行（request line）</li>
<li>请求头部（header）</li>
<li>空行</li>
<li>请求数据<h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3>HTTP响应也由四个部分组成，分别是：</li>
<li>状态行</li>
<li>消息报头</li>
<li>空行</li>
<li>响应正文<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3>客户端请求<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /hello.<span class="property">txt</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: curl/<span class="number">7.16</span><span class="number">.3</span> libcurl/<span class="number">7.16</span><span class="number">.3</span> <span class="title class_">OpenSSL</span>/<span class="number">0.9</span>.7l zlib/<span class="number">1.2</span><span class="number">.3</span></span><br><span class="line"><span class="title class_">Host</span>: www.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span>: en, mi</span><br></pre></td></tr></table></figure>
服务端响应<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Date</span>: <span class="title class_">Mon</span>, <span class="number">27</span> <span class="title class_">Jul</span> <span class="number">2009</span> <span class="number">12</span>:<span class="number">28</span>:<span class="number">53</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">Server</span>: <span class="title class_">Apache</span></span><br><span class="line"><span class="title class_">Last</span>-<span class="title class_">Modified</span>: <span class="title class_">Wed</span>, <span class="number">22</span> <span class="title class_">Jul</span> <span class="number">2009</span> <span class="number">19</span>:<span class="number">15</span>:<span class="number">56</span> <span class="variable constant_">GMT</span></span><br><span class="line"><span class="title class_">ETag</span>: <span class="string">&quot;34aa387-d-1568eb00&quot;</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Ranges</span>: bytes</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">51</span></span><br><span class="line"><span class="title class_">Vary</span>: <span class="title class_">Accept</span>-<span class="title class_">Encoding</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: text/plain</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h2><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 </p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。 </p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 </p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">GET</td>
<td align="center">请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>2</td>
<td align="center">HEAD</td>
<td align="center">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>3</td>
<td align="center">POST</td>
<td align="center">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>4</td>
<td align="center">PUT</td>
<td align="center">从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>5</td>
<td align="center">DELETE</td>
<td align="center">请求服务器删除指定的页面</td>
</tr>
<tr>
<td>6</td>
<td align="center">CONNECT</td>
<td align="center">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>7</td>
<td align="center">OPTIONS</td>
<td align="center">允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>8</td>
<td align="center">TRACE</td>
<td align="center">回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td>9</td>
<td align="center">PATCH</td>
<td align="center">是对 PUT 方法的补充，用来对已知资源进行局部更新</td>
</tr>
</tbody></table>
<h2 id="http响应头信息"><a href="#http响应头信息" class="headerlink" title="http响应头信息"></a>http响应头信息</h2><table>
<thead>
<tr>
<th>响应头</th>
<th align="center">说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td align="center">服务器支持哪些请求方法（如GET、POST等）</td>
<td align="center"></td>
</tr>
<tr>
<td>Content-Encoding</td>
<td align="center">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型</td>
<td align="center">默认byte,利用gzip压缩文档能够显著地减少HTML文档的下载时间。</td>
</tr>
<tr>
<td>Content-Length</td>
<td align="center">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。</td>
<td align="center"></td>
</tr>
<tr>
<td>Content-Type</td>
<td align="center">表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html</td>
<td align="center">常见multipart/form-data,application/json <a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-content-type.html">content-type</a></td>
</tr>
<tr>
<td>Date</td>
<td align="center">当前的GMT时间。可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>
<td align="center"></td>
</tr>
<tr>
<td>Expires</td>
<td align="center">应该在什么时候认为文档已经过期，从而不再缓存它</td>
<td align="center"></td>
</tr>
<tr>
<td>Last-Modified</td>
<td align="center">文档的最后改动时间</td>
<td align="center">可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态</td>
</tr>
<tr>
<td>Location</td>
<td align="center">表示客户应当到哪里去提取文档</td>
<td align="center"></td>
</tr>
<tr>
<td>Refresh</td>
<td align="center">表示浏览器应该在多少时间之后刷新文档</td>
<td align="center">注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展</td>
</tr>
<tr>
<td>Server</td>
<td align="center">服务器名字</td>
<td align="center">Servlet一般不设置这个值，而是由Web服务器自己设置</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td align="center">设置和页面关联的Cookie</td>
<td align="center"></td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td align="center">客户应该在Authorization头中提供什么类型的授权信息</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>&emsp;&emsp;当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。<br>常见状态码:  </p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h3 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h3><ul>
<li>1**    信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2**    成功，操作被成功接收并处理</li>
<li>3**    重定向，需要进一步的操作以完成请求</li>
<li>4**    客户端错误，请求包含语法错误或无法完成请求</li>
<li>5**    服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<h2 id="常见HTTP状态码列表"><a href="#常见HTTP状态码列表" class="headerlink" title="常见HTTP状态码列表:"></a>常见HTTP状态码列表:</h2><table>
<thead>
<tr>
<th>状态码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td align="center">OK  请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>301</td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td align="center">与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>304</td>
<td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td align="center">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td align="center">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>400</td>
<td align="center">Bad Request    客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td>403</td>
<td align="center">Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td align="center">Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td align="center">Method Not Allowed    客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>410</td>
<td align="center">Gone    客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>413</td>
<td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求</td>
</tr>
<tr>
<td>414</td>
<td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>500</td>
<td align="center">Internal Server Error    服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td align="center">Not Implemented    服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td align="center">Bad Gateway    作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>504</td>
<td align="center">Gateway Time-out  充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td align="center">HTTP Version not supported    服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h2 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h2><h3 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a>HTTP和HTTPS的基本概念</h3><p>　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。  </p>
<p>　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。  </p>
<p>　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。  </p>
<h3 id="HTTPS和HTTP的区别主要如下："><a href="#HTTPS和HTTP的区别主要如下：" class="headerlink" title="HTTPS和HTTP的区别主要如下："></a>HTTPS和HTTP的区别主要如下：</h3><p>　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  </p>
<h3 id="客户端在使用HTTPS方式与Web服务器通信时步骤"><a href="#客户端在使用HTTPS方式与Web服务器通信时步骤" class="headerlink" title="客户端在使用HTTPS方式与Web服务器通信时步骤"></a>客户端在使用HTTPS方式与Web服务器通信时步骤</h3><p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。<br>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。<br>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>　　（5）Web服务器利用自己的私钥解密出会话密钥。<br>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。    </p>
<h3 id="https的优缺点"><a href="#https的优缺点" class="headerlink" title="https的优缺点"></a>https的优缺点</h3><p> <strong>HTTPS的优点</strong><br>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：<br>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。<br>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。<br>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。<br> <strong>HTTPS的缺点</strong><br>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：<br>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；<br>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；<br>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。<br>　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。<br>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。  </p>
<h3 id="HTTPS协议的工作原理"><a href="#HTTPS协议的工作原理" class="headerlink" title="HTTPS协议的工作原理"></a>HTTPS协议的工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<p>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</p>
<ul>
<li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li>
<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器通过自己的私钥解密出会话密钥。</li>
<li>web 服务器通过会话密钥加密与客户端之间的通信。</li>
</ul>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="ajax发完整请求"><a href="#ajax发完整请求" class="headerlink" title="ajax发完整请求"></a>ajax发完整请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>)&#123;</span><br><span class="line">  request=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">//IE7+,...</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  request=<span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>); <span class="comment">//IE6,IE5</span></span><br></pre></td></tr></table></figure>
<p>用XHR发送请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open(method,url,async) // 调用XHR对象，async表示同步还是异步，默认为true(异步)；</span></span><br><span class="line"><span class="comment">// send(String)   // 发送请求。</span></span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;create.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">request.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);  <span class="comment">//必须写在open和send中间</span></span><br><span class="line">request.<span class="title function_">send</span>(<span class="string">&quot;name=王大锤&amp;sex=男&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>一、xhr取得响应  </p>
<ul>
<li>responseText:获得字符串形式的相应数据。  </li>
<li>responsXML:获得XML形式的相应数据。  </li>
<li>status和statusText：以数字和文本形式返回http状态码。  </li>
<li>getAllResponseHeader()：获取所有的响应报头。  </li>
<li>getResponseHeader()：查询响应中的某个字段的值。  </li>
<li>readyState属性：响应返回成功的时候得到通知。<br>（1）0：请求未初始化，open还没有调用。<br>（2）1：服务器连接已建立，open已经调用了。<br>（3）2：请求已经接收，也就是接收到头信息了。<br>（4）3：请求处理中，也就是接收到响应主体了。<br>（5）4：请求已完成，且响应已就绪，也就是响应完成了。    </li>
</ul>
<p>二、典型的xhr建立ajax的过程。（涵盖了ajax的大部分内容）  </p>
<ul>
<li>new一个xhr对象。</li>
<li>调用xhr对象的open方法。</li>
<li>send一些数据。</li>
<li>对服务器的响应过程进行监听，来知道服务器是否正确得做出了响应，接着就可以做一些事情。比如获取服务器响应的内容，在页面上进行呈现。</li>
</ul>
<h3 id="get-post请求的区别："><a href="#get-post请求的区别：" class="headerlink" title="get/post请求的区别："></a>get/post请求的区别：</h3><ol>
<li><p>GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务器。当然在Ajax请求中，这种区别对用户是不可见的。  </p>
</li>
<li><p>首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。  </p>
</li>
<li><p>GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。  </p>
</li>
<li><p>在客户端使用get请求时,服务器端使用Request.QueryString来获取参数,而客户端使用post请求时,服务器端使用Request.Form来获取参数.(服务器端的区别)  </p>
</li>
</ol>
<p>HTTP标准包含这两种方法是为了达到不同的目的。<br>POST用于创建资源，资源的内容会被编入HTTP请示的内容中。<br>当请求无副作用时（如进行搜索），便可使用GET方法；<br>当请求有副作用时（如添加数据行），则用POST方法。  </p>
<p>一个比较实际的问题是：GET方法可能会产生很长的URL，或许会超过某些浏览器与服务器对URL长度的限制。<br>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<h3 id="jquery中的ajax"><a href="#jquery中的ajax" class="headerlink" title="jquery中的ajax"></a>jquery中的ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;service.php?number=&quot;</span>+$(<span class="string">&quot;#keyword&quot;</span>).<span class="title function_">val</span>(),</span><br><span class="line">        <span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>, 预期服务器返回数据的类型</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(data.<span class="property">success</span>)&#123;</span><br><span class="line">               $(<span class="string">&quot;searchResult&quot;</span>).<span class="title function_">html</span>(data.<span class="property">msg</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               $(<span class="string">&quot;#searchResult&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;出现错误：&quot;</span> + data.<span class="property">msg</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>:<span class="keyword">function</span>(<span class="params">jqXHR</span>)&#123;</span><br><span class="line">           <span class="title function_">aler</span>(<span class="string">&quot;发生错误：&quot;</span>+ jqXHR.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>jquery中的ajax方法参数</strong>  </p>
<ol>
<li><p>url:<br>要求为String类型的参数，（默认为当前页地址）发送请求的地址。 </p>
</li>
<li><p>type:<br>要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。</p>
</li>
<li><p>timeout:<br>要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。</p>
</li>
<li><p>async:<br>要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</p>
</li>
<li><p>cache:<br>要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。</p>
</li>
<li><p>data:<br>要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。</p>
</li>
<li><p>dataType:<br>要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：</p>
</li>
</ol>
<ul>
<li>xml：返回XML文档，可用JQuery处理。</li>
<li>html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。</li>
<li>script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。</li>
<li>json：返回JSON数据。</li>
<li>jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。</li>
<li>text：返回纯文本字符串。</li>
</ul>
<ol start="8">
<li><p>beforeSend：<br>要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">XMLHttpRequest</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>;   <span class="comment">//调用本次ajax请求时传递的options参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>complete：<br>要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>;    <span class="comment">//调用本次ajax请求时传递的options参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。</p>
<pre><code> (1)由服务器返回，并根据dataType参数进行处理后的数据。  
 (2)描述状态的字符串。  
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">data, textStatus</span>)&#123;</span><br><span class="line">  <span class="comment">//data可能是xmlDoc、jsonObj、html、text等等</span></span><br><span class="line">  <span class="variable language_">this</span>;  <span class="comment">//调用本次ajax请求时传递的options参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>error:<br>要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>)&#123;</span><br><span class="line">  <span class="comment">//通常情况下textStatus和errorThrown只有其中一个包含信息</span></span><br><span class="line">  <span class="variable language_">this</span>;   <span class="comment">//调用本次ajax请求时传递的options参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>contentType：<br>要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。</p>
</li>
<li><p>dataFilter：<br>要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">data, type</span>)&#123;</span><br><span class="line">  <span class="comment">//返回处理后的数据</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>dataFilter：<br>要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">data, type</span>)&#123;</span><br><span class="line">  <span class="comment">//返回处理后的数据</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>global：<br>要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。</p>
</li>
<li><p>ifModified：<br>要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。</p>
</li>
<li><p>jsonp：<br>要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。</p>
</li>
<li><p>username：<br>要求为String类型的参数，用于响应HTTP访问认证请求的用户名。</p>
</li>
<li><p>password：<br>要求为String类型的参数，用于响应HTTP访问认证请求的密码。</p>
</li>
<li><p>processData：<br>要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。</p>
</li>
<li><p>scriptCharset：<br>要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。</p>
</li>
</ol>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p><strong>引用</strong><br>ES6 import引用<br>因为axios不是vue的插件，所以不能直接用use方法，需要将其加载到原型上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">axios.<span class="title function_">get</span>();</span><br></pre></td></tr></table></figure>
<p>如果要全局使用axios就需要在main.js中设置成全局的，然后再组件中通过this调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$axios</span> = axios;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$axios</span>.<span class="title function_">get</span>();</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong><br>发送一个最简单的请求<br>发送一个带参数的get请求，params参数放在get方法的第二个参数中，如果没有参数get方法里可以只写路径。如果请求失败捕获一下异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .<span class="title function_">get</span>(<span class="string">&#x27;http://rap2api.taobao.org/app/mock/23080/resources/search&#x27;</span>,&#123;</span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">id</span>: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据是:&#x27;</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据失败&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以发送一个POST请求，post方法的第二个参数为请求参数对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$axios</span>.<span class="title function_">post</span>(<span class="string">&#x27;http://rap2api.taobao.org/app/mock/121145/post&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;小月&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一次合并发送多个请求<br>分别写两个请求函数，利用axios的all方法接收一个由每个请求函数组成的数组，可以一次性发送多个请求，如果全部请求成功，在axios.spread方法接收一个回调函数，该函数的参数就是每个请求返回的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermissions</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$axios</span>.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(),<span class="title function_">getUserPermissions</span>()])</span><br><span class="line">  .<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(<span class="keyword">function</span>(<span class="params">res1,res2</span>)&#123;</span><br><span class="line">    <span class="comment">//当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p><strong>axios的API</strong><br>以上通过axios直接调用发放来发起对应的请求其实是axios为了方便起见给不同的请求提供的别名方法。我们完全可以通过调用axios的API，传递一个配置对象来发起请求。</p>
<ul>
<li>发送post请求，参数写在data属性中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://rap2api.taobao.org/app/mock/121145/post&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小月&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求结果：&#x27;</span>, res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>发送get请求，默认就是get请求，直接第一个参数写路径，第二个参数写配置对象，参数通过params属性设置。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(<span class="string">&#x27;http://rap2api.taobao.org/app/mock/121145/get&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小月&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求结果：&#x27;</span>, res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
axios为所有请求方式都提供了别名：  <table>
<thead>
<tr>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>axios.request(config)</td>
</tr>
<tr>
<td>axios.get(url, [config])</td>
</tr>
<tr>
<td>axios.delete(url, [config])</td>
</tr>
<tr>
<td>axios.head(url, [config])</td>
</tr>
<tr>
<td>axios.options(url, [config])</td>
</tr>
<tr>
<td>axios.post(url, [data], [config])</td>
</tr>
<tr>
<td>axios.put(url, [data], [config])</td>
</tr>
<tr>
<td>axios.patch(url, [data], [config])</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>axios配置默认值</strong><br>1、可以通过axios.defaults设置全局默认值，在所有请求中都生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&quot;token&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">post</span>[<span class="string">&quot;Content-type&quot;</span>] = <span class="string">&quot;application/json&quot;</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;https://service.xxx.com; //设置统一路径前缀</span></span><br></pre></td></tr></table></figure>
<p>2、也可以自定义实例的默认值，以及修改实例的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时自定义默认配置，超时设置为全局默认值0秒</span></span><br><span class="line"><span class="keyword">let</span> ax = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://rap2api.taobao.org&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;小月&#x27;</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改配置后，超时设置为4秒</span></span><br><span class="line">ax.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">4000</span>; </span><br></pre></td></tr></table></figure>
<p>3、也可以像前面那样，在每个请求中设置相关的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(<span class="string">&#x27;/app/mock/121145/get&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaoxiao&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://rap2api.taobao.org&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上配置方法优先级从1-3依次增高，更多配置选项查看文档。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    method：<span class="string">&#x27;请求方法&#x27;</span>,</span><br><span class="line">    baseURL：<span class="string">&#x27;如果路径不是绝对路径，就会在路径前自动添加此路径&#x27;</span>,</span><br><span class="line">    <span class="attr">transformRequest</span>: [<span class="function">(<span class="params">data, header</span>)=&gt;</span>&#123;&#125;], <span class="comment">//在发送请求之前修改数据，适用于post、put、patch</span></span><br><span class="line">    <span class="attr">transformResponse</span>:  [<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data).<span class="property">data</span>;</span><br><span class="line">    &#125;], <span class="comment">//在收到的数据传到then之前修改数据，注意这里data是个字符串类型。</span></span><br><span class="line">    <span class="attr">header</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;, <span class="comment">//请求头</span></span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;, <span class="comment">//请求参数</span></span><br><span class="line">    <span class="attr">paramsSerializer</span>: <span class="function">(<span class="params">params</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qs.<span class="title function_">stringify</span>(params); <span class="comment">//name=xiaohong&amp;id=1</span></span><br><span class="line">    &#125; <span class="comment">//可选函数，可以把参数拼接成字符串</span></span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;, <span class="comment">// post类方法的请求体参数</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">0</span>, <span class="comment">//请求延时事件，如果超时请求终止</span></span><br><span class="line">    <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">//是否时跨站点请求</span></span><br><span class="line">    <span class="attr">onUploadProgress</span>: <span class="function">(<span class="params">progressEvent</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//可以通过progressEvent拿到上传的进度</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onDownloadProgress</span>: <span class="function">()=&gt;</span>&#123;&#125;,<span class="comment">//和onUploadProgress一样，获取下载的进度</span></span><br><span class="line">    <span class="attr">responseType</span>: json,  <span class="comment">// 返回的数据格式</span></span><br><span class="line">    <span class="attr">maxContentLength</span>: <span class="number">2000</span>, <span class="comment">//相应内容的最大尺寸</span></span><br><span class="line">    <span class="attr">validateStatus</span>: <span class="function">(<span class="params">validateStatus</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> validateStatus &gt;= <span class="number">200</span>; <span class="comment">//限制相应状态码，如果不满足就拒绝</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title function_">cancelToken</span>(<span class="keyword">function</span>(<span class="params">cancel</span>)&#123;&#125;) <span class="comment">// 指定一个取消请求标识，下面会用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>axios拦截器</strong><br>可以分别设置请求拦截和响应拦截，在发出请求和响应到达then之前进行判断处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>以上以相应拦截器为例，请求拦截器同样，只是把response换成request。第一个参数是成功回调，第二个是错误回调。<br>也可以移除拦截器，就像移除js定时器一样的操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor);</span><br></pre></td></tr></table></figure>
<p><strong>取消请求</strong><br>1、取消请求的话需要先通过创建一个CancelToken.source工厂函数创建一个标识source<br>2、通过配置项制定标识，这样才知道取消的是哪个请求<br>3、调用取消方法  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">var</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>(); <span class="comment">//1</span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;new name&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span> <span class="comment">//2</span></span><br><span class="line">&#125;)</span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;Operation canceled by the user.&#x27;</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>还有一种写法是直接把cancelToken的构造函数传递给配置项，该构造函数接受一个函数作为参数，在这个函数中指定标识符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/app/mock/121145/get&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://rap2api.taobao.org&#x27;</span>,</span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>) &#123;</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">cancel</span>();</span><br></pre></td></tr></table></figure>
<p><strong>跨域配置</strong><br>如果我们要跨域请求数据，在配置文件里设置代理，vue-cli3项目，需要在根目录自己创建一个vue.config.js，在里面写配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;https://www.xxx.com&#x27;</span>, <span class="comment">//目标路径，别忘了加http和端口号</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">        <span class="attr">ws</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">//重写路径</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>调用接口：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/test&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;xiao&#x27;</span>&#125;); </span><br><span class="line">如果没有重写路径，访问的就是<span class="attr">https</span>:<span class="comment">//www.xxx.com/api/test，如果像上面代码那样重写路径访问的就是https://www.xxx.com/test。</span></span><br></pre></td></tr></table></figure>
<p>原理：<br>因为客户端请求服务端的数据是存在跨域问题的，而服务器和服务器之间可以相互请求数据，是没有跨域的概念（如果服务器没有设置禁止跨域的权限问题），也就是说，我们可以配置一个代理的服务器可以请求另一个服务器中的数据，然后把请求出来的数据返回到我们的代理服务器中，代理服务器再返回数据给我们的客户端，这样我们就可以实现跨域访问数据啦。</p>
<h2 id="浏览器相关知识"><a href="#浏览器相关知识" class="headerlink" title="浏览器相关知识"></a>浏览器相关知识</h2><h3 id="七层协议模型"><a href="#七层协议模型" class="headerlink" title="七层协议模型"></a>七层协议模型</h3><p>四层协议和七层协议:</p>
<ul>
<li>osi七层协议</li>
</ul>
<ol>
<li>物理层：网卡，网线，集线器，中继器，调制解调器  </li>
<li>数据链路层：网桥，交换机  </li>
<li>网络层：路由器  </li>
<li>传输层  </li>
<li>会话层  </li>
<li>表示层  </li>
<li>应用层<br>网关工作在第四层传输层及其以上</li>
</ol>
<ul>
<li>tcp模型<br>网络接口层—-网间层—-传输层—-应用层</li>
</ul>
<h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><p>浏览器的内核主要分为渲染引擎和JS引擎<br>页面加载过程:<br>    1.  浏览器根据DNS域名服务器解析域名得到IP地址；<br>    2.  向这个IP地址发起HTTP请求；<br>    3.  服务器收到，处理，返回HTTP请求;<br>    4.  浏览器得到返回的内容。<br>     一、浏览器如何渲染网页<br>    要了解浏览器渲染页面的过程，首先得知道一个名词——关键路径渲染。关键渲染路径（Critical Rendering Path）是指与当前用户操作有关的内容。例如用户在浏览器中打开一个页面，其中页面所显示的东西就是当前用户操作相关的内容，也就是浏览器从服务器那收到的HTML,CSS,JavaScript等相关资源，然后经过一系列处理后渲染出来的web页面。<br>    浏览器渲染的过程主要包括以下五步：<br>    　　① 浏览器将获取的HTML文档解析成DOM树<br>    　　② 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)<br>    　　③ 将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象<br>    　　④ 渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素<br>    　　⑤ 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting  </p>
<p>需要注意的是，以上五个步骤并不一定一次性顺序完成，比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。<br> 二、浏览器渲染网页的具体流程<br> 1、构建DOM树<br>　　当浏览器客户端从服务器那接受到HTML文档后，就会遍历文档节点然后生成DOM树，DOM树结构和HTML标签一一对应。需要注意记下几点：<br>  ① DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。<br>  ② display:none 的元素也会在DOM树中。<br>  ③ 注释也会在DOM树中<br>  ④ script标签会在DOM树中  </p>
<p>渲染过程中，如果遇到 &lt; script &gt;就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。<br>JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。<br>解决方案：这是为什么建议把&lt; script &gt;标签放到&lt; body &gt;的最后面的原因。如果不放在最后，也可使用defer或者async属性，异步加载js文件。二者的区别是：async会在下载完之后立即执行；而defer会等到DOM Tree解析完成之后再去执行  </p>
<p> 2、CSS解析<br>浏览器会解析CSS文件并生成CSS规则树，在过程中，每个CSS文件都会被分析成StyleSheet对象，每个对象都包括CSS规则，CSS规则对象包括对应的选择器和声明对象以及其他对象。<br>在这个过程需要注意的是：<br>　　① CSS解析可以与DOM解析同进行<br>　　② CSS解析与script的执行互斥<br>　　③ 在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥3、构建渲染树（Rendr tree construction）  </p>
<p>通过DOM树和CSS规则树，浏览器就可以通过这两个构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。具体的规则有以下几点需要注意：<br>　　① Render Tree和DOM Tree不完全对应<br>　　② display: none的元素不在Render Tree中<br>　　③ visibility: hidden的元素在Render Tree中4、渲染树布局(layout of the render tree)<br>布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：<br>　　① float元素，absoulte元素，fixed元素会发生位置偏移<br>　　② 我们常说的脱离文档流，其实就是脱离Render Tree5、渲染树绘制（Painting the render tree）<br>在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。  </p>
<p> 三、浏览器渲染网页的那些事儿<br> 1、阻塞渲染<br>　　现代浏览器总是并行加载自语言。例如当HTML解析器被脚本阻塞时，解析器虽然会停止构建DOM，但仍然会辨识该脚本后面的资源，并进行预加载。且由于以下两点。浏览器会延迟 JavaScript 的执行和 DOM 构建：<br>　　① CSS 被默认被视为阻塞渲染的资源，因此浏览器将在 CSSOM 构建完毕前不会渲染任何已处理的内容。<br>　　② JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性，因此CSS解析与script的执行互斥。<br>正是由于以上这些原因，script标签的位置很重要我们在实际开发中应该尽量坚持以下两个原则：</p>
<ul>
<li>在引入顺序上，CSS 资源先于 JavaScript 资源。</li>
<li>JavaScript 应尽量少的去影响 DOM 的构建</li>
</ul>
<p> 2、回流和重绘（reflow和repaint）<br>HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念:<br>　　① reflow（回流）：当浏览器发现某个部分发生了变化从而影响了布局，这个时候就需要倒回去重新渲染，大家称这个回退的过程叫 reflow。<br>　　常见的reflow是一些会影响页面布局的操作，诸如Tab，隐藏等。reflow 会从 html 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。reflow几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会reflow哪一部分的代码，因为他们会相互影响。<br>　　② repaint（重绘）： repaint则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。<br>需要注意的是，display:none 会触发 reflow，而visibility: hidden属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，这在我们上面有提到过。所以 visibility:hidden 只会触发 repaint，因为没有发生位置变化。</p>
<p>我们不能避免reflow，但还是能通过一些操作来减少回流：<br>　　① 用transform做形变和位移<br>　　② 通过绝对位移来脱离当前层叠上下文，形成新的Render Layer  </p>
<p>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。<br> 3、几条关于优化渲染效率的建议<br>　　① 合法地去书写 HTML 和 CSS ，且不要忘了文档编码类型。<br>　　② 样式文件应当在 head 标签中，而脚本文件在 body 结束前，这样可以防止阻塞的方式。<br>　　③ 简化并优化CSS选择器，尽量将嵌套层减少到最小。<br>　　④ 尽量减少在 JavaScript 中进行DOM操作。<br>　　⑤ 修改元素样式时，更改其class属性是性能最高的方法。<br>　　⑥ 尽量用 transform 来做形变和位移  </p>
<h3 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h3><p> cookie与session<br>|         区别       |       cookie       |       session        |<br>| ——————– |:——————:|:——————:|<br>|    保持状态    |   保存在浏览器端       |  保存在服务器端 |<br>|    使用方式    |   第一次登陆后，服务器会生成一个cookie，并通过set-cookie响应头将包含有cookie的数据传给浏览器，然后被浏览器保存在本地。当该用户发送第二次请求时，浏览器就会自动把上次存储的Cookie携带在请求中发送给服务器，服务器根据这个Cookie就可以判断是哪个用户进行的操作。Cookie在生成时就会被指定一个Expire值，这就是Cookie的生存周期，在这个周期内Cookie有效，超出周期Cookie就会被清除。有些页面将Cookie的生存周期设置为“0”或负值，这样在关闭浏览器时，就马上清除Cookie，不会记录用户信息，更加安全。      | 有了Cookie来区分身份，还需要session来存储用户详细信息以供调用，因为这些信息是是隐私信息，直接把信息通过cookie发到并保存在客户端是很不安全的，且cookie大小不能超过4k，不支持中文。当浏览器发起一个请求时，服务器会先检查是否携带了存有SessionID的cookie。如果有，那么就会从服务器的session里取出这个ID对应的session返回给浏览器。如果客户端请求中没有SessionID，服务器会创建新的session，并把SessionID返回给客户端。 |<br>|    存储内容    |   只能保存字符串类型       | 通过类Hashtable的数据结构来保存，支持任何类型的对象(session中可含有多个对象)  |<br>|    存储大小    |   单个cookie保存的数据不能超过4kb       | session大小没有限制  |<br>|    安全性    |   cookie不如session       |  1）SessionID存储在cookie中，若要攻破session首先要攻破cookie；  （2）SessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到SessionID；  （3）第二次启动session_start后，前一次的SessionID就是失效了，session过期后，SessionID也随之失效。  （4）SessionID是加密的|<br>|    应用场景    |  （1）判断用户身份，以便下次登录时能够实现单点登录（或记住密码）。（2）保存上次登录的时间等信息。（3）保存上次查看的页面      |   （1）网上商城中的购物车（2）保存用户登录（3）将某些数据放入session中，供同一用户的不同页面使用（4）防止用户非法登录|<br>|    缺点    | （1）大小受限（2）用户可以操作（禁用）cookie，使功能受限（3）安全性较低（4）有些状态不可能保存在客户端。（5）每次访问都要传送cookie给服务器，浪费带宽。（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。       |  （1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。（2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全（3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。</p>
<p> WebStorage与cookie<br>|         区别       |       cookie       |       WebStorage        |<br>| ——————– |:——————:|:——————:|<br>|    存储空间    |   4KB       |  5MB |<br>|    传输方式    |   在每次请求中都会传送到服务器，不管是否被需要       |  不会传送到服务器，存储在本地的数据可以直接获取，所以不必担心被截取。 |<br>|    过期时间    |   由设置的Expire决定，到期就会销毁，如果这个值为0或负数，就是会话期间有效。       |  localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失，除非主动删除数据。sessionStorage的生命周期是在仅在当前会话下有效，关闭了浏览器窗口后就会被销毁。 |<br>|    快速获取    |          |  有的数据存储在WebStorage上，从本地获取会比从服务器端获取快得多 |<br>|    可操作性    |          |  setItem (key, value)  //保存数据，以键值对的方式储存信息。getItem (key)  //获取数据，将键值传入，即可获取到对应的value值。removeItem (key)  //删除单个数据，根据键值移除对应的信息。clear ()  //删除所有的数据key (index)  //获取某个索引的key</p>
<p> sessionStorage与localStorage<br>|         区别       |       sessionStorage       |       localStorage        |<br>| ——————– |:——————:|:——————:|<br>|    生命周期    |   永久的，关闭页面或浏览器之后localStorage中的数据也不会消失，除非主动删除数据。       |  仅在当前会话下有效，关闭了浏览器窗口后就会被销毁。 |<br>|    存储大小    |   5MB       |  5MB |<br>|    存储位置    |   保存在客户端，不与服务器进行交互通信       |   |<br>|    存储内容类型    |只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理     |   |<br>|    获取方式    |   window.sessionStorage       |  window.localStorage  |<br>|    应用场景    |   适合单页应用各业务模块之间传值；       |  存储用户的一些设置；记录浏览器对页面的访问次数； |</p>
<h3 id="从输入url到页面渲染过程中发生了什么"><a href="#从输入url到页面渲染过程中发生了什么" class="headerlink" title="从输入url到页面渲染过程中发生了什么"></a>从输入url到页面渲染过程中发生了什么</h3><p>从输入URL到渲染出整个页面的过程包括三个部分：</p>
<p>1、DNS解析URL的过程</p>
<p>2、浏览器发送请求与服务器交互的过程</p>
<p>3、浏览器对接收到的html页面渲染的过程  </p>
<p> 一、DNS解析URL的过程</p>
<p>  DNS解析的过程就是寻找哪个服务器上有请求的资源。因为ip地址不容易记忆，一般会使用URL域名（如<a target="_blank" rel="noopener" href="http://www.baidu.com)作为网址.dns解析就是将域名翻译成ip地址的过程./">www.baidu.com）作为网址。DNS解析就是将域名翻译成IP地址的过程。</a></p>
<p>具体过程<br>     1）浏览器缓存：浏览器会按照一定的频率 缓存DNS记录  </p>
<p> 　　2）操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会取操作系统中找  </p>
<p>　　 3）路由缓存：路由器也有DNS缓存  </p>
<p>　　 4）ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求  </p>
<p>　　 5）根服务器：ISP的DNS服务器找不到之后，就要向根服务器发出请求，进行递归查询  </p>
<p> 二、浏览器与服务器交互过程</p>
<p>　　1）首先浏览器利用tcp协议通过三次握手与服务器建立连接(具体过程下面写)  </p>
<p>　　http请求包括header和body。header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie。body中有请求的内容。  </p>
<p>　　2）浏览器根据解析到的IP地址和端口号发起http的get请求.  </p>
<p>　　3）服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文  </p>
<p>　　4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染  </p>
<p> 三、浏览器页面渲染过程</p>
<p>　　1）浏览器根据深度遍历的方式把html节点遍历成dom 树  </p>
<p>　　2）将css解析成CSS DOM树  </p>
<p>　　3）将dom树和CSS DOM树构造成render树  </p>
<p>　　4）JS根据得到的render树 计算所有节点在屏幕中的位置，进行布局（回流）  </p>
<p>　　5）遍历render树并调用硬件API绘制所有节点（重绘）  </p>
<p>构造render渲染树的过程  </p>
<ul>
<li><p>从DOM树的根节点开始遍历每个可见的节点。</p>
</li>
<li><p>对于每个可见的节点，找到CSS树中的对应的规则，并且应用他们。</p>
</li>
<li><p>根据每个可见的节点及其对应的样式，组合生成渲染树。</p>
<p>三次握手</p>
</li>
<li><p>第一次握手:<br>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p>
</li>
<li><p>第二次握手:<br>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p>
</li>
<li><p>第三次握手.<br>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1  </p>
</li>
</ul>
<p>简单讲:<br>第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的<br>但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。<br>进行第三次握手的原因:<br>当网络原因服务端没有收到客户端的请求，且没有给客户端反馈。超时后客户端会再次向服务端发送请求。当网络畅通后服务器段收到最开始的请求并反馈给客户端。导致客户端认为自己未发送这个请求，服务端认为自己发送了一个新的请求，导致服务端性能浪费。</p>
<p> 四次挥手</p>
<ol>
<li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待状态)。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
</li>
<li><p>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
</li>
<li><p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p>
</li>
<li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
</li>
<li><p>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
</li>
<li><p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
</li>
</ol>
<h3 id="TCP-IP-如何保证数据包传输的有序可靠？"><a href="#TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP/IP / 如何保证数据包传输的有序可靠？"></a>TCP/IP / 如何保证数据包传输的有序可靠？</h3><p>对字节流分段并进行编号然后通过 ACK 回复和超时重发这两个机制来保证。</p>
<ol>
<li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</li>
<li>并为每个已发送的数据包启动一个超时定时器；</li>
<li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</li>
<li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li>
<li>接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li>
</ol>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol>
<li>TCP是面向链接的，而UDP是面向无连接的。</li>
<li>TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能。</li>
<li>TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li>
<li>UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ajax/" rel="tag">ajax</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/status-code/" rel="tag">status code</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/07/typeScript/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          TypeScript
        
      </div>
    </a>
  
  
    <a href="/2022/11/07/html/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">html</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">http消息结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF"><span class="nav-number">1.1.</span> <span class="nav-text">客户端请求消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.</span> <span class="nav-text">服务器响应消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">http请求方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="nav-number">3.</span> <span class="nav-text">http响应头信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">http状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">HTTP状态码分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%97%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">常见HTTP状态码列表:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E4%B8%8Ehttps"><span class="nav-number">6.</span> <span class="nav-text">http与https</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">HTTP和HTTPS的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%BB%E8%A6%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">6.2.</span> <span class="nav-text">HTTPS和HTTP的区别主要如下：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E4%BD%BF%E7%94%A8HTTPS%E6%96%B9%E5%BC%8F%E4%B8%8EWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E6%97%B6%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.3.</span> <span class="nav-text">客户端在使用HTTPS方式与Web服务器通信时步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#https%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">6.4.</span> <span class="nav-text">https的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.5.</span> <span class="nav-text">HTTPS协议的工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ajax"><span class="nav-number">7.</span> <span class="nav-text">Ajax</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ajax%E5%8F%91%E5%AE%8C%E6%95%B4%E8%AF%B7%E6%B1%82"><span class="nav-number">7.1.</span> <span class="nav-text">ajax发完整请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-post%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">get&#x2F;post请求的区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jquery%E4%B8%AD%E7%9A%84ajax"><span class="nav-number">7.3.</span> <span class="nav-text">jquery中的ajax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#axios"><span class="nav-number">7.4.</span> <span class="nav-text">axios</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">8.</span> <span class="nav-text">浏览器相关知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.1.</span> <span class="nav-text">七层协议模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">浏览器渲染原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie%E4%B8%8Esession"><span class="nav-number">8.3.</span> <span class="nav-text">cookie与session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">8.4.</span> <span class="nav-text">从输入url到页面渲染过程中发生了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="nav-number">8.5.</span> <span class="nav-text">TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.6.</span> <span class="nav-text">TCP和UDP的区别</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2022 Vesper Diesel All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/scripts.js"></script>





  
<script src="/js/dialog.js"></script>









	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Vesper Diesel
          </div>
          <div class="panel-body">
            Copyright © 2022 Vesper All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>